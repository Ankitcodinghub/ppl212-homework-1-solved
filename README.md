# ppl212-homework-1-solved
**TO GET THIS SOLUTION VISIT:** [PPL212 Homework 1 Solved](https://www.ankitcodinghub.com/product/ppl212-homework-1-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;92015&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;0&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;0&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;0\/5 - (0 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;PPL212 Homework 1 Solved&quot;,&quot;width&quot;:&quot;0&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 0px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            <span class="kksr-muted">Rate this product</span>
    </div>
    </div>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
Testing Your Code

Every TypeScript assignment will have Mocha and Chai as dependencies for testing purposes. In order to run the tests, save your tests in the test directory in a file ending with .test.ts and run npm test from a command prompt. This will activate the execution of the tests you have specified in the test file and report the results of the tests in a very nice format.

An example test file assignmentX.test.ts might look like this: import { expect } from ‚Äúchai‚Äù;

<pre>import { sum } from "../src/assignmentX";
</pre>
<pre>describe("Assignment X", () =&gt; {
  it("sums two numbers", () =&gt; {
</pre>
<pre>    expect(sum(1, 2)).to.equal(3);
  });
</pre>
});

Every function you want to test must be export-ed, for example, in assignmentX.ts, so that it can be

import-ed in the .test.ts file (and by our automatic test script when we grade the assignment). export const sum = (a: number, b: number) =&gt; a + b;

You are given some basic tests in the test directory, just to make sure you are on the right track during the assignment.

What to Submit

You should submit a zip file called &lt;id1&gt;_&lt;id2&gt;.zip which has the following structure: /

<pre>     Part1.pdf
     src
</pre>
<pre>        part2
           part2.ts
</pre>
<pre>        part3
           find.ts
</pre>
<pre>           state.ts
           queue.ts
           stack.ts
</pre>
Make sure that when you extract the zip (using unzip on Linux), the result is flat, i.e., not inside a folder. This structure is crucial for us to be able to import your code to our tests. Also, make sure the file is a .zip file ‚Äì not a RAR or TAR or any other compression format.

</div>
</div>
<div class="layoutArea">
<div class="column">
2

</div>
</div>
</div>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
Part 1: Theoretical Questions

Submit the solution to this part as Part1.pdf. We can‚Äôt stress this enough: the file has to be a PDF file.

<ol>
<li>Explain the following programming paradigms:
(a) Imperative (b) Procedural (c) Functional

How does the procedural paradigm improve over the imperative paradigm? How does the functional paradigm improve over the procedural paradigm?
</li>
<li>Write the most specific types for the following expressions: (a) (x, y) =&gt; x.some(y)

(b) x =&gt; x.reduce((acc, cur) =&gt; acc + cur, 0)

(c) (x, y) =&gt; x ? y[0] : y[1]</li>
<li>Explain the concept of ‚Äúabstraction barriers‚Äù.</li>
</ol>
Part 2: Fun with TypeScript

Complete the following functions in TypeScript in the file src/part2/part2.ts. One of the assignment‚Äôs dependencies is the Ramda library shown in class, and you may use it freely. Make sure to write your code using type annotations, and adhering to the Functional Programming paradigm, i.e., use only const for variable declarations (which also means no loops), and no using push, pop, shift, unshift, splice, sort, reverse, fill on arrays.

You may use helper functions as much as you want, but they must follow the same constraints as above.

You are also given a helper function stringToArray which takes a string and returns an array of the characters that make up the string. For example:

stringToArray(‚ÄúHello!‚Äù); // ==&gt; [ ‚ÄòH‚Äô, ‚Äòe‚Äô, ‚Äòl‚Äô, ‚Äòl‚Äô, ‚Äòo‚Äô, ‚Äò!‚Äô ]

You are encouraged to use Ramda‚Äôs pipe function, which takes a list of functions and returns a function which ‚Äúpipes‚Äù the functions one after the other. It is similar to compose, but the order of applications is reversed. For example:

<pre>import { pipe } from "ramda";
</pre>
<pre>const f = pipe(
    (x: number) =&gt; x * x,
    (x: number) =&gt; x + 1,
    (x: number) =&gt; 2 * x
</pre>
);

f(5); // ==&gt; 52

Remember that it is crucial you do not remove the export keyword from the code in the given template.

</div>
</div>
<div class="layoutArea">
<div class="column">
3

</div>
</div>
</div>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
Question 1

Write a function countVowels that takes a string as input and returns the number of vowels in the text. Reminder: vowels are one of ‚Äòa‚Äô, ‚Äòe‚Äô, ‚Äòi‚Äô, ‚Äòo‚Äô, ‚Äòu‚Äô, either uppercase or lowercase. For example:

countVowels(‚ÄúThis is SOME Text‚Äù); // ==&gt; 5 Question 2

Write a function runLengthEncoding which takes a string as input and returns a ‚Äúcompressed‚Äù version of it, where identical consecutive characters appear as the character followed by its count. For example:

runLengthEncoding(‚Äúaaaabbbccd‚Äù); // ==&gt; ‚Äòa4b3c2d‚Äô Question 3

Write a function isPaired that takes a string and returns whether the parentheses ({, }, (, ), [, ]) in the string are paired. For example:

isPaired(‚ÄúThis is ([some]) {text}‚Äù); // ==&gt; true isPaired(‚ÄúThis is ]some[ (text)‚Äù); // ==&gt; false

Part 3: A Fistful of Monads

What is a monad? According to Wikipedia: ‚ÄúIn functional programming, a monad is a design pattern that allows structuring programs generically while automating away boilerplate code needed by the program logic. Monads achieve this by providing their own data type (a particular type for each type of monad), which represents a specific form of computation, along with one procedure to wrap values of any basic type within the monad (yielding a monadic value) and another to compose functions that output monadic values (called monadic functions).‚Äù

During the semester, we will use two such monads: the Result&lt;T&gt; monad (used to deal with computations that may fail) and the Optional&lt;T&gt; monad (used when a computation might not yield a value).

The main function used with monads is the bind function (also called chain and flatmap in other languages, and by the &gt;&gt;= operator in Haskell). bind is used to compose two monads in a way that makes sense in the context of the specific monad.

In your solution, in addition to Result&lt;T&gt; and State&lt;S, A&gt;, use only TypeScript constructs and types that are functional, i.e., under the same constraints as in Part 2, and that were covered in class.

</div>
</div>
<div class="layoutArea">
<div class="column">
4

</div>
</div>
</div>
<div class="page" title="Page 5">
<div class="layoutArea">
<div class="column">
When All Else Fails

We are going to get very familiar with the Result&lt;T&gt; monad in our interpreters‚Äô code, so to get up and running with using it and getting to know its constructors and its bind function, we will convert a function that throws an error to a function that uses Result&lt;T&gt;.

1. Read the code in src/lib/result.ts. Try to understand how bind composes two Result&lt;T&gt; values. 2. In src/part3/find.ts, you are given this code:

<pre>     /* Library code */
</pre>
<pre>     const findOrThrow = &lt;T&gt;(pred: (x: T) =&gt; boolean, a: T[]): T =&gt; {
         for (let i = 0; i &lt; a.length; i++) {
</pre>
<pre>             if (pred(a[i])) return a[i];
         }
</pre>
<pre>         throw "No element found.";
     }
</pre>
<pre>     /* Client code */
</pre>
<pre>     const returnSquaredIfFoundEven_v1 = (a: number[]): number =&gt; {
         try {
</pre>
<pre>             const x = findOrThrow(x =&gt; x % 2 === 0, a);
</pre>
<pre>             return x * x;
         } catch (e) {
</pre>
return -1; }

}

(a) Write a generic pure function findResult which takes a predicate and an array, and returns an

Ok of the first element that the predicate returns true for, or a Failure if no such element exists.

<ol start="2">
<li>(b) &nbsp;Only using bind, write a function returnSquaredIfFoundEven_v2 that uses findResult to return
an Ok of the first even value squared, or a Failure if no even numbers exist.
</li>
<li>(c) &nbsp;Only using either, write a function returnSquaredIfFoundEven_v3 that uses findResult to
return the first even value squared, or a ‚àí1 if no even numbers exist.
</li>
</ol>
‚ÄúL‚ÄôE ÃÅtat, c‚Äôest moi.‚Äù

Many computations involve state in some way or another: random number generation, defined variables, mutable data structures, etc. As we already know, managing state with mutation is contrary to the functional paradigm. To avoid managing state with mutation, we introduce the State monad.

Let‚Äôs explore the concrete example of random number generation. Suppose we have a pure function random for generating pseudo-random numbers given a seed value:

<pre>const random = (seed: number): number =&gt;
    (80189 * seed + 190886) % 1052010;
</pre>
To use it, we just need to keep track of the new seed coming out of the function:

const seed0 = 42;

const seed1 = random(seed0); console.log(seed1); // ==&gt; 402794 const seed2 = random(seed1); console.log(seed2); // ==&gt; 1027932

</div>
</div>
<div class="layoutArea">
<div class="column">
5

</div>
</div>
</div>
<div class="page" title="Page 6">
<div class="layoutArea">
<div class="column">
This isn‚Äôt so bad, but consider the following client code to roll a die:

<pre>const randomDie = (seed: number): number =&gt; {
    const newSeed = random(seed);
    return 1 + Math.floor(newSeed / 1052010 * 6);
</pre>
};

const seed = 42;

const die1 = randomDie(seed);

const die2 = randomDie(seed); console.log(die1, die2); // ==&gt; 3 3

This is no good, we are getting the same die roll, because the seed didn‚Äôt change. What we need to do is keep track of the new seed, which is the state of the pseudo-random number generator. We can change the randomDie function like so:

<pre>const randomDie = (seed: number): [number, number] =&gt; {
    const newSeed = random(seed);
    const die = 1 + Math.floor(newSeed / 1052010 * 6);
    return [newSeed, die];
</pre>
};

const seed0 = 42;

const [seed1, die1] = randomDie(seed0); const [seed2, die2] = randomDie(seed1); console.log(die1, die2); // ==&gt; 3 6

Almost perfect! We are getting different die rolls, but passing the seeds around when we compose multiple calls of the function is cumbersome and risk-prone. We want to abstract the way successive calls to a state are threaded from one call to the next in a state composition function. This is what is defined in the bind function associated with this monad.

To this end, we will define the State monad to be a function from the initial state of type S to a pair of the new state and result of the computation: type State&lt;S, A&gt; = (initialState: S) =&gt; [S, A];

Note: the type [S, A] is a type that represents an array of size 2 where the first element is of type S and the second element is of type A. This is known in TypeScript as a ‚Äútuple‚Äù.

The name ‚ÄúState monad‚Äù can be a little confusing, as the State&lt;S, A&gt; instance is actually a ‚Äústate proces- sor‚Äù, and S is the type of the internal state we are keeping.

Back to our die-rolling function: assume we have implemented die of type State&lt;number, number&gt;, and the monadic composition function bind (we are not showing you how to do this here). We can now implement a function to roll two dice without explicitly passing around the seed like so:

<pre>const rollTwoDice: State&lt;number, [number, number]&gt; =
    bind(die, die1 =&gt; bind(die, die2 =&gt; s =&gt; [s, [die1, die2]]));
</pre>
const seed = 42;

const [newSeed, dice] = rollTwoDice(seed); console.log(dice); // ==&gt; [ 3, 6 ]

Excellent! We have the correct values for the dice as before, and we didn‚Äôt have to interleave the seed between the computations: we only needed to give the initial seed value.

</div>
</div>
<div class="layoutArea">
<div class="column">
6

</div>
</div>
</div>
<div class="page" title="Page 7">
<div class="layoutArea">
<div class="column">
Now that we have the motivation for the State monad, implement in src/part3/state.ts the function bind. Its signature is:

<pre>const bind: &lt;S, A, B&gt;(state: State&lt;S, A&gt;, f: (x: A) =&gt; State&lt;S, B&gt;) =&gt; State&lt;S, B&gt;
</pre>
Think how bind should behave, and let its type guide your implementation.

Now that we have the State monad and its bind function defined, we can put them to good use. We saw in class how to implement a functional stack, but that required keeping track of intermediate stacks. We will now implement a functional queue and stack using the State monad.

Implement the following in src/part3/queue.ts:

1. enqueue is a function which takes a number x and returns a State that adds x to the queue. 2. dequeue is a State which dequeues a number from the queue and returns it.

Also in src/part3/queue.ts, implement queueManip which does the following only using bind, enqueue, and dequeue!

1. Dequeues a number x from the queue 2. Enqueues 2 * x

3. Enqueues x / 3

4. Dequeues

For example (remember that queueManip is a State): queueManip([6, 7, 8]); // ==&gt; [ [ 8, 12, 2 ], 7 ] In src/part3/stack.ts, implement the following:

1. push is a function which takes a number x and returns a State that adds x to the stack.

2. pop is a State which pops a number from the stack and returns it.

Same as with our queue, add a definition for stackManip in src/part3/stack.ts which does the following

only using bind, push, and pop! 1. Pops a number x

2. Pushes x * x

3. Pops a number y

4. Pushes x + y

For example:

console.log(stackManip([4, 5, 6])); // ==&gt; [ [ 20, 5, 6 ], undefined ] Note: we won‚Äôt check cases of dequeuing an empty queue, or popping an empty stack.

</div>
</div>
</div>
